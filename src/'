/***********************************************/
//STANDARD HEADERS
/************************************************/
#include <iostream>
#include <cmath>
#include <vector>
#include <utility>
#include <chrono>
#include <unordered_map> 
#include <queue>
#include <fstream>
#include <thread>
#include <ctime>

/*********************************************/
//PCL HEADERS
/**********************************************/
#include <pcl/io/ply_io.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/impl/point_types.hpp>
#include <pcl/filters/voxel_grid.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/features/normal_3d.h>
#include <pcl/surface/gp3.h>
#include <pcl/io/vtk_io.h>
#include <pcl/io/vtk_lib_io.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/io/ply_io.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/registration/icp.h>
#include <pcl/filters/convolution_3d.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/visualization/cloud_viewer.h>

/*********************************************/
//OTHER HEADERS
/**********************************************/
#include <cv.h>
#include <highgui.h>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <Eigen/Dense>
#include <Eigen/Core>
#include <boost/algorithm/string.hpp>

using namespace boost::algorithm;
using namespace std;
using namespace pcl;
using namespace Eigen;
using namespace cv;

namespace VisualizationUtilities
{
    class PCLVisualizerWrapper
    {
        pcl::visualization::PCLVisualizer::Ptr viewer_;
        public:
        PCLVisualizerWrapper()
        {
            pcl::visualization::PCLVisualizer::Ptr viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
            viewer_=viewer;
            viewer_->setBackgroundColor (0, 0, 0);
            viewer_->initCameraParameters ();
        }
        void addPointCloud(PointCloud<PointXYZRGBNormal>::Ptr cloud);
        bool spinViewer();
        void clear();
    };

    void PCLVisualizerWrapper::addPointCloud(PointCloud<PointXYZRGBNormal>::Ptr cloud)
    {
        viewer_->addPointCloud<PointXYZRGBNormal>(cloud,"sample cloud");
    }
    bool PCLVisualizerWrapper::spinViewer()
    {
        if(viewer_->wasStopped())
            return false;
        viewer_->spinOnce(100);
        return true;
    }
    void PCLVisualizerWrapper::clear()
    {
        viewer_->removeAllPointClouds();
        viewer_->removeAllShapes(); 
    }
}

namespace PointCloudProcessing
{
    template <typename PointT> static pcl::PointCloud<PointT> downsample(pcl::PointCloud<PointT> cloud,double leaf)
    {
        pcl::VoxelGrid<PointT> sor;
        pcl::PointCloud<PointT> cloud_filtered;
        sor.setLeafSize (leaf, leaf, leaf);
        sor.setInputCloud (cloud.makeShared());
        sor.filter (cloud_filtered);
        return cloud_filtered;
    }
    PointCloud<PointXYZRGBNormal> makePointCloudNormal(PointCloud<PointXYZRGB>& cloud,vector<double>& viewpoint)
    {
        pcl::PointCloud<PointXYZ> cloud_xyz;
        for(int i=0;i<cloud.points.size();i++)
        {
            cloud_xyz.points.push_back({cloud.points[i].x,cloud.points[i].y,cloud.points[i].z});
        }
        PointCloud<PointXYZ>::Ptr cloud_in = cloud_xyz.makeShared();
        pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
        ne.setInputCloud (cloud_in);
        pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ> ());
        ne.setSearchMethod (tree);
        pcl::PointCloud<pcl::Normal>::Ptr cloud_normals (new pcl::PointCloud<pcl::Normal>);
        ne.setRadiusSearch (0.005);
        ne.setViewPoint(viewpoint[0],viewpoint[1],viewpoint[2]);
        ne.compute (*cloud_normals); 
        PointCloud<PointXYZRGBNormal> output_cloud;
        for(int i=0;i<cloud.points.size();i++)
        {
            PointXYZRGBNormal pt;
            pt.x=cloud.points[i].x;
            pt.y=cloud.points[i].y;
            pt.z=cloud.points[i].z;
            pt.rgb=cloud.points[i].rgb;
            pt.normal[0]=cloud_normals->points[i].normal[0];
            pt.normal[1]=cloud_normals->points[i].normal[1];
            pt.normal[2]=cloud_normals->points[i].normal[2];
            output_cloud.push_back(pt);
        }
        output_cloud.height=1;
        output_cloud.width=cloud.points.size();
        return output_cloud;
    }
}

namespace DebuggingUtilities
{
    void print(){std::cout<<std::endl;}
    template<typename T,typename... Args>
        void print(T Contents, Args... args) 
        {
            std::cout<< (Contents) <<" ";print(args...);
        }
}

int main(int argc, char** argv)
{
    pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGBNormal>);
#if 0
    if (pcl::io::loadPCDFile<pcl::PointXYZRGBNormal> ("/home/rex/REX_WS/Catkin_WS/data/base.pcd", *cloud) == -1) //* load the file
    {
        PCL_ERROR ("Couldn't read file for base. \n");
        return (-1);
    }
#else
    pcl::PLYReader Reader;
    Reader.read("/home/rex/REX_WS/Test_WS/POINT_CLOUD_STITCHING/data/empty_box_inside/1.ply", *cloud);
#endif
    VisualizationUtilities::PCLVisualizerWrapper viz;
    viz.addPointCloud(cloud);
    while(viz.spinViewer());
    std::thread thread_viz(); 
    thread_viz.join();
    return 0;
}
